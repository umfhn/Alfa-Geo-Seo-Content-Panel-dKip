import { GoogleGenAI, Type } from "@google/genai";
import type { Panel, Geo, UserInput } from '../types';

// This service encapsulates all direct communication with the Google GenAI API.

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// Define a strict JSON schema for the AI's response to ensure consistency.
const panelSchema = {
  type: Type.OBJECT,
  properties: {
    slug: { type: Type.STRING, description: 'Ein SEO-freundlicher Slug für das Panel, z.B. "kernleistungen-in-berlin".' },
    title: { type: Type.STRING, description: 'Ein kreativer und einzigartiger Titel für das Panel mit GEO-Bezug.' },
    summary: { type: Type.STRING, description: 'Eine prägnante Zusammenfassung des Panel-Inhalts in 2-3 Sätzen.' },
    sections: {
      type: Type.ARRAY,
      description: 'Eine Liste von 2-3 inhaltlichen Abschnitten, die als Akkordeons dargestellt werden.',
      items: {
        type: Type.OBJECT,
        properties: {
          title: { type: Type.STRING, description: 'Der Titel des Akkordeon-Abschnitts.' },
          bullets: {
            type: Type.ARRAY,
            description: 'Eine Liste von 3-5 aussagekräftigen Stichpunkten.',
            items: { type: Type.STRING }
          }
        },
        required: ['title', 'bullets']
      }
    },
    faqs: {
      type: Type.ARRAY,
      description: 'Eine Liste von 2-3 relevanten "Häufig gestellten Fragen".',
      items: {
        type: Type.OBJECT,
        properties: {
          q: { type: Type.STRING, description: 'Die Frage.' },
          a: { type: Type.STRING, description: 'Die Antwort.' }
        },
        required: ['q', 'a']
      }
    },
    keywords: {
      type: Type.ARRAY,
      description: 'Eine Liste von 5-8 relevanten Keywords für dieses Panel.',
      items: { type: Type.STRING }
    }
  },
  required: ['slug', 'title', 'summary', 'sections', 'faqs', 'keywords']
};

const createPrompt = (userInput: UserInput, topic: string, existingTitles: string[]): string => {
    const { geo, tone, contentDepth } = userInput;

    const existingTitlesPrompt = existingTitles.length > 0
        ? `Bestehende Titel (vermeide Duplikate und zu hohe Ähnlichkeit): ${existingTitles.join(', ')}`
        : 'Dies ist das erste Panel, es gibt noch keine anderen Titel.';

    return `
      Erstelle den Inhalt für ein einzelnes Content-Panel für die Firma "${geo.companyName}" in ${geo.city}, ${geo.region}.
      Die Firma ist in der Branche "${geo.branch}" tätig.
      
      **Thema des Panels:** "${topic}"

      **Anforderungen:**
      1.  **Tonalität:** ${tone}.
      2.  **Detailgrad:** ${contentDepth}. Erstelle entsprechend viele/detaillierte Inhalte.
      3.  **GEO-Fokus:** Integriere die Ortsangaben (${geo.city}, ${geo.region}) und den Firmennamen organisch und sinnvoll in die Texte, insbesondere im Titel und in der Zusammenfassung.
      4.  **Einzigartigkeit:** Der Titel muss sich deutlich von den bereits existierenden Titeln unterscheiden.
      5.  **Struktur:** Halte dich exakt an das vorgegebene JSON-Schema. Fülle alle Felder.

      ${existingTitlesPrompt}

      Basierend auf diesen Informationen, generiere jetzt das JSON-Objekt für das Panel.
    `;
};

/**
 * Generates a single panel using the Gemini API with a structured response.
 * Implements the "Live AI" logic.
 */
export const generateSinglePanelLive = async (userInput: UserInput, topic: string, existingTitles: string[]): Promise<Panel> => {
    const prompt = createPrompt(userInput, topic, existingTitles);

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: panelSchema,
                temperature: 0.7, // Lower temperature for more deterministic but still creative results
            },
        });

        const jsonString = response.text;
        const generatedPanel = JSON.parse(jsonString) as Omit<Panel, 'kind' | 'sources' | 'payloadHash'>;
        
        // Enrich the panel with fields not generated by the AI
        return {
            ...generatedPanel,
            kind: 'accordion',
            sources: [], // Sources would be added by a grounding feature
            payloadHash: `live-hash-${new Date().getTime()}`
        };

    } catch (error) {
        console.error("Gemini API call failed:", error);
        let errorMessage = "Ein unbekannter KI-Fehler ist aufgetreten.";
        if (error instanceof Error) {
            // This is a basic check. Real Gemini API errors might have more structure.
            if (error.message.includes('SAFETY')) {
                errorMessage = "Inhaltsfilter blockiert: Der generierte Inhalt wurde aufgrund von Sicherheitsrichtlinien blockiert. Versuchen Sie, das Thema umzuformulieren.";
            } else if (error.message.includes('429')) { // Assuming rate limit errors contain status code
                errorMessage = "Rate-Limit erreicht: Zu viele Anfragen in kurzer Zeit. Bitte warten Sie einen Moment.";
            } else if (error.message.toLowerCase().includes('json')) {
                 errorMessage = "Formatfehler: Die KI hat ein ungültiges JSON-Format zurückgegeben. Ein automatischer Neuversuch wird gestartet.";
            } else {
                errorMessage = `KI-Fehler: ${error.message}`;
            }
        }
        throw new Error(errorMessage);
    }
};

/**
 * A simple diagnostic function to test the AI connection.
 */
export const runAIPing = async (): Promise<{ ok: boolean, latency_ms: number, message: string }> => {
    const startTime = Date.now();
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: "Antworte nur mit 'pong'.",
             config: { 
                thinkingConfig: { thinkingBudget: 0 },
                maxOutputTokens: 5 
            }
        });
        const latency = Date.now() - startTime;
        if (response.text.trim().toLowerCase() === 'pong') {
            return { ok: true, latency_ms: latency, message: 'OK' };
        }
        return { ok: false, latency_ms: latency, message: 'Unerwartete Antwort von der KI.' };
    } catch (error) {
        const latency = Date.now() - startTime;
        console.error("AI Ping failed:", error);
        return { ok: false, latency_ms: latency, message: error instanceof Error ? error.message : 'Unbekannter Fehler' };
    }
};

/**
 * Generates SEO-optimized title and meta description based on provided content.
 */
export const generateSeoMetadataFromContent = async (
    companyName: string,
    city: string,
    mainTopic: string,
    allPanelContent: string
): Promise<{ title: string; description: string }> => {

    const seoSchema = {
        type: Type.OBJECT,
        properties: {
            title: {
                type: Type.STRING,
                description: 'Ein SEO-optimierter Seitentitel. Muss den Firmennamen und die Stadt enthalten. Maximal 60 Zeichen.'
            },
            description: {
                type: Type.STRING,
                description: 'Eine ansprechende Meta-Beschreibung, die zum Klicken anregt. Maximal 155 Zeichen.'
            }
        },
        required: ['title', 'description']
    };

    const prompt = `
      Basierend auf den folgenden Inhalten für das Unternehmen "${companyName}" in "${city}" zum Hauptthema "${mainTopic}", erstelle einen SEO-optimierten Seitentitel und eine Meta-Beschreibung.

      **Anforderungen:**
      - **Titel:** Maximal 60 Zeichen. Muss den Firmennamen und die Stadt enthalten. Sollte das Hauptthema widerspiegeln und einzigartig sein.
      - **Beschreibung:** Maximal 155 Zeichen. Sollte eine klare Handlungsaufforderung enthalten und die wichtigsten Dienstleistungen zusammenfassen.

      **Inhalts-Zusammenfassung:**
      ---
      ${allPanelContent.substring(0, 3000)} 
      ---

      Generiere jetzt das JSON-Objekt mit Titel und Beschreibung.
    `;

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: seoSchema,
                temperature: 0.6,
            },
        });

        const jsonString = response.text;
        return JSON.parse(jsonString) as { title: string; description: string };

    } catch (error) {
        console.error("Gemini API call for SEO metadata failed:", error);
        // Throw the error so the calling function can handle it (e.g., fall back to a template)
        throw new Error("Fehler bei der Generierung der SEO-Metadaten.");
    }
};