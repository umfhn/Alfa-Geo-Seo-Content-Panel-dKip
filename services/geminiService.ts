

import { GoogleGenAI, Type } from "@google/genai";
import type { Panel, Geo, UserInput } from '../types';
import { t } from '../i18n';

// This service encapsulates all direct communication with the Google GenAI API.

// FIX: Per @google/genai guidelines, the API key must be provided via environment variables.
// UI-based key management has been removed.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });


/**
 * Retrieves the initialized AI client.
 * @throws An error if the API key is not configured.
 * @returns The GoogleGenAI client instance.
 */
const getClient = (): GoogleGenAI => {
    // The API key is mandatory for the service to function.
    if (!process.env.API_KEY) {
        // This error message should be translated. Assuming 't' function handles it.
        throw new Error(t('error.apiKeyMissing'));
    }
    return ai;
};


// Define a strict JSON schema for the AI's response to ensure consistency.
const panelSchema = {
  type: Type.OBJECT,
  properties: {
    slug: { type: Type.STRING, description: 'Ein SEO-freundlicher Slug für die Sektion, z.B. "kernleistungen-in-berlin".' },
    title: { type: Type.STRING, description: 'Ein kreativer und einzigartiger Titel für die Sektion mit GEO-Bezug.' },
    summary: { type: Type.STRING, description: 'Eine prägnante Zusammenfassung des Sektions-Inhalts in 2-3 Sätzen.' },
    sections: {
      type: Type.ARRAY,
      description: 'Eine Liste von 2-3 inhaltlichen Abschnitten, die als Akkordeons dargestellt werden.',
      items: {
        type: Type.OBJECT,
        properties: {
          title: { type: Type.STRING, description: 'Der Titel des Akkordeon-Abschnitts.' },
          bullets: {
            type: Type.ARRAY,
            description: 'Eine Liste von 3-5 aussagekräftigen Stichpunkten.',
            items: { type: Type.STRING }
          }
        },
        required: ['title', 'bullets']
      }
    },
    faqs: {
      type: Type.ARRAY,
      description: 'Eine Liste von 2-3 relevanten "Häufig gestellten Fragen".',
      items: {
        type: Type.OBJECT,
        properties: {
          q: { type: Type.STRING, description: 'Die Frage.' },
          a: { type: Type.STRING, description: 'Die Antwort.' }
        },
        required: ['q', 'a']
      }
    },
    keywords: {
      type: Type.ARRAY,
      description: 'Eine Liste von 5-8 relevanten Keywords für diese Sektion.',
      items: { type: Type.STRING }
    }
  },
  required: ['slug', 'title', 'summary', 'sections', 'faqs', 'keywords']
};

const createPrompt = (userInput: UserInput, topic: string, existingTitles: string[]): string => {
    const { geo, tone, contentDepth } = userInput;

    const existingTitlesPrompt = existingTitles.length > 0
        ? `Bestehende Titel (vermeide Duplikate und zu große Ähnlichkeit): ${existingTitles.join(', ')}`
        : 'Dies ist die erste Sektion, es gibt noch keine anderen Titel.';

    return `
      Erstelle den Inhalt für eine einzelne Content-Sektion für die Firma "${geo.companyName}" in ${geo.city}, ${geo.region}.
      Die Firma ist in der Branche "${geo.branch}" tätig.
      
      **Thema der Sektion:** "${topic}"

      **Anforderungen:**
      1.  **Tonalität:** ${tone}.
      2.  **Detailgrad:** ${contentDepth}. Erstelle entsprechend viele/detaillierte Inhalte.
      3.  **GEO-Fokus:** Integriere die Ortsangaben (${geo.city}, ${geo.region}) und den Firmennamen organisch und sinnvoll in die Texte, insbesondere im Titel und in der Zusammenfassung.
      4.  **Einzigartigkeit:** Der Titel muss sich deutlich von den bereits existierenden Titeln unterscheiden.
      5.  **Struktur:** Halte dich exakt an das vorgegebene JSON-Schema. Fülle alle Felder.

      ${existingTitlesPrompt}

      Basierend auf diesen Informationen, generiere jetzt das JSON-Objekt für die Sektion.
    `;
};

/**
 * Generates a single panel using the Gemini API with a structured response.
 * Implements the "Live AI" logic.
 */
export const generateSinglePanelLive = async (userInput: UserInput, topic: string, existingTitles: string[]): Promise<Panel> => {
    const prompt = createPrompt(userInput, topic, existingTitles);
    const client = getClient();

    try {
        const response = await client.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: panelSchema,
                temperature: 0.7, // Lower temperature for more deterministic but still creative results
            },
        });

        // FIX: Trim whitespace from the response before parsing to prevent errors with leading/trailing characters.
        const jsonString = response.text.trim();
        const generatedPanel = JSON.parse(jsonString) as Omit<Panel, 'kind' | 'sources' | 'payloadHash'>;
        
        // Enrich the panel with fields not generated by the AI
        return {
            ...generatedPanel,
            kind: 'accordion',
            sources: [], // Sources would be added by a grounding feature
            payloadHash: `live-hash-${new Date().getTime()}`
        };

    } catch (error) {
        console.error("Gemini API call failed:", error);
        let errorMessage = "Ein unbekannter KI-Fehler ist aufgetreten.";
        if (error instanceof Error) {
            // This is a basic check. Real Gemini API errors might have more structure.
            if (error.message.includes('SAFETY')) {
                errorMessage = "Inhaltsfilter blockiert: Der generierte Inhalt wurde aufgrund von Sicherheitsrichtlinien blockiert. Versuchen Sie, das Thema umzuformulieren.";
            } else if (error.message.includes('429')) { // Assuming rate limit errors contain status code
                errorMessage = "Rate-Limit erreicht: Zu viele Anfragen in kurzer Zeit. Bitte warten Sie einen Moment.";
            } else if (error.message.toLowerCase().includes('json')) {
                 errorMessage = "Formatfehler: Die KI hat ein ungültiges JSON-Format zurückgegeben. Ein automatischer Neuversuch wird gestartet.";
            } else {
                errorMessage = `KI-Fehler: ${error.message}`;
            }
        }
        throw new Error(errorMessage);
    }
};

// FIX: Add a prompt creation function for regenerating a specific segment of a panel.
const createSegmentRegeneratePrompt = (userInput: UserInput, panel: Panel, segment: string, existingTitles: string[]): string => {
    const { geo, tone, contentDepth } = userInput;
    const panelContent = JSON.stringify(panel, null, 2);

    const existingTitlesPrompt = existingTitles.length > 0
        ? `Bestehende Titel (vermeide Duplikate und zu große Ähnlichkeit): ${existingTitles.join(', ')}`
        : 'Dies ist die erste Sektion, es gibt noch keine anderen Titel.';

    return `
      Aufgabe: Regeneriere NUR das Segment "${segment}" für das folgende JSON-Objekt.
      Behalte alle anderen Segmente exakt bei. Gib das vollständige JSON-Objekt mit dem aktualisierten Segment zurück.

      **Kontext:**
      Firma: "${geo.companyName}" in ${geo.city}, ${geo.region} (${geo.branch}).
      Tonalität: ${tone}
      Detailgrad: ${contentDepth}
      GEO-Fokus: Integriere die Ortsangaben (${geo.city}, ${geo.region}) und den Firmennamen organisch in die neuen Texte.
      Einzigartigkeit: Falls der Titel regeneriert wird, muss er sich von den bestehenden unterscheiden.

      ${existingTitlesPrompt}
      
      **Bestehendes JSON-Objekt:**
      \`\`\`json
      ${panelContent}
      \`\`\`

      Generiere jetzt das vollständige JSON-Objekt mit dem aktualisierten Segment "${segment}".
    `;
};

// FIX: Add a new exported function to handle segment regeneration via the Gemini API.
/**
 * Regenerates a specific segment of a panel.
 */
export const regeneratePanelSegment = async (userInput: UserInput, panel: Panel, segment: string, existingTitles: string[]): Promise<Panel> => {
    // For segment regeneration, we ask the model to regenerate one part but return the full object
    // to ensure schema validity.
    const prompt = createSegmentRegeneratePrompt(userInput, panel, segment, existingTitles);
    const client = getClient();

    try {
        const response = await client.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: panelSchema,
                temperature: 0.75, // Slightly higher temp for creative changes
            },
        });

        // FIX: Trim whitespace from the response before parsing to prevent errors with leading/trailing characters.
        const jsonString = response.text.trim();
        const regeneratedPanel = JSON.parse(jsonString) as Omit<Panel, 'kind' | 'sources' | 'payloadHash'>;
        
        // Return the full panel, but keep some original metadata
        return {
            ...regeneratedPanel,
            kind: panel.kind,
            sources: panel.sources,
            payloadHash: `live-hash-${new Date().getTime()}` // New hash for new content
        };

    } catch (error) {
        console.error(`Gemini API call failed for segment regeneration (${segment}):`, error);
        // Reuse error handling from generateSinglePanelLive for consistency
        let errorMessage = `Ein Fehler ist bei der Regenerierung des Segments '${segment}' aufgetreten.`;
        if (error instanceof Error) {
            if (error.message.includes('SAFETY')) {
                errorMessage = `Inhaltsfilter blockiert: Der Inhalt für Segment '${segment}' wurde blockiert.`;
            } else if (error.message.includes('429')) {
                errorMessage = `Rate-Limit erreicht bei Regenerierung von Segment '${segment}'.`;
            } else if (error.message.toLowerCase().includes('json')) {
                 errorMessage = `Formatfehler (Segment '${segment}'): Die KI hat ein ungültiges JSON-Format zurückgegeben.`;
            } else {
                errorMessage = `KI-Fehler (Segment '${segment}'): ${error.message}`;
            }
        }
        throw new Error(errorMessage);
    }
};


/**
 * A simple diagnostic function to test the AI connection.
 */
export const runAIPing = async (): Promise<{ ok: boolean, latency_ms: number, message: string }> => {
    const startTime = Date.now();
    const client = getClient();
    try {
        const response = await client.models.generateContent({
            model: "gemini-2.5-flash",
            contents: "Antworte nur mit 'pong'.",
// FIX: Removed `maxOutputTokens` from the config for this low-latency check. 
// The guidelines recommend avoiding this parameter unless necessary, and the "disable thinking"
// use case example does not include it.
             config: { 
                thinkingConfig: { thinkingBudget: 0 }
            }
        });
        const latency = Date.now() - startTime;
        if (response.text.trim().toLowerCase() === 'pong') {
            return { ok: true, latency_ms: latency, message: 'OK' };
        }
        return { ok: false, latency_ms: latency, message: 'Unerwartete Antwort von der KI.' };
    } catch (error) {
        const latency = Date.now() - startTime;
        console.error("AI Ping failed:", error);
        return { ok: false, latency_ms: latency, message: error instanceof Error ? error.message : 'Unbekannter Fehler' };
    }
};

/**
 * Generates SEO-optimized title and meta description based on provided content.
 */
export const generateSeoMetadataFromContent = async (
    companyName: string,
    city: string,
    mainTopic: string,
    allPanelContent: string
): Promise<{ title: string; description: string }> => {

    const seoSchema = {
        type: Type.OBJECT,
        properties: {
            title: {
                type: Type.STRING,
                description: 'Ein SEO-optimierter Seitentitel. Muss den Firmennamen und die Stadt enthalten. Maximal 60 Zeichen.'
            },
            description: {
                type: Type.STRING,
                description: 'Eine ansprechende Meta-Beschreibung, die zum Klicken anregt. Maximal 155 Zeichen.'
            }
        },
        required: ['title', 'description']
    };

    const prompt = `
      Basierend auf den folgenden Inhalten für das Unternehmen "${companyName}" in "${city}" zum Hauptthema "${mainTopic}", erstelle einen SEO-optimierten Seitentitel und eine Meta-Beschreibung.

      **Anforderungen:**
      - **Titel:** Maximal 60 Zeichen. Muss den Firmennamen und die Stadt enthalten. Sollte das Hauptthema widerspiegeln und einzigartig sein.
      - **Beschreibung:** Maximal 155 Zeichen. Sollte eine klare Handlungsaufforderung enthalten und die wichtigsten Dienstleistungen zusammenfassen.

      **Inhalts-Zusammenfassung:**
      ---
      ${allPanelContent.substring(0, 3000)} 
      ---

      Generiere jetzt das JSON-Objekt mit Titel und Beschreibung.
    `;
    const client = getClient();

    try {
        const response = await client.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: seoSchema,
                temperature: 0.6,
            },
        });

        // FIX: Trim whitespace from the response before parsing to prevent errors with leading/trailing characters.
        const jsonString = response.text.trim();
        return JSON.parse(jsonString) as { title: string; description: string };

    } catch (error) {
        console.error("Gemini API call for SEO metadata failed:", error);
        let errorMessage = "Fehler bei der Generierung der SEO-Metadaten.";
        if (error instanceof Error) {
            if (error.message.includes('SAFETY')) {
                errorMessage = "SEO-Generierung blockiert: Der Inhalt wurde aufgrund von Sicherheitsrichtlinien blockiert.";
            } else if (error.message.includes('429')) {
                errorMessage = "Rate-Limit für SEO-Generierung erreicht. Bitte warten Sie einen Moment.";
            } else if (error.message.toLowerCase().includes('json')) {
                 errorMessage = "Formatfehler (SEO): Die KI hat ein ungültiges JSON-Format zurückgegeben.";
            } else {
                errorMessage = `KI-Fehler (SEO): ${error.message}`;
            }
        }
        // Throw the specific error message
        throw new Error(errorMessage);
    }
};
